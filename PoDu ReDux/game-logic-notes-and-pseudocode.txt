ability_check()

eventIDs{KO, to_ultra_space, from_ultra_space, to_pc, from_pc, from_pc_rotation, eliminated, returned, to_bench, from_bench, movement, battle_start, battle_end, plate_used, plate_expired, plate_restored, }

###
Generic Ability and Attack Effects
###

# Accounts for all status effects without separate functions
def apply_status(targets, status_name):
#status_name not necessary to remove ALL statuses
def remove_status(targets, *status_name):

# Accounts for all markers and allows new markers without too much adjustment
def apply_marker(targets, marker_name):
#marker_name not necessary to remove ALL markers
def remove_marker(targets, *marker_name):

# Wait effects stack additively
def apply_wait(targets, duration):
def remove_wait(targets):

# Accounts for reversion effects, i.e. backtrack (celebi, gross)
def evolve(targets):
def devolve(targets):
def original_state(targets):
#probably gonna need a separate timer function for Megas/Ultra Necrozma
def mega_evolve(targets):
#Accounts for Ultra Necrozma
def form_change(targets, duration):

# Allows for single- or multi-targeting
def target_ko(targets):
def target_remove(targets):
def target_to_ultra_space(targets):
def target_to_board(targets):
def target_to_bench(targets):
def target_to_pc(targets):
def target_to_other_pc(targets):
def swap_spot(targets):

# OR
# Summarizes all possible movements into one function with conditionals
def targetMove(targets, eligibleOrigin, eligibleNewLocation, cause):

# Allows for changing of entire wheel (i.e. targetsegments = color in movelist, targetcolor red for terrakion-like effects) or just one segment (ex. X-Speed)
def zmove_wheel():
def change_gold(targets, targetsegments, targetcolor):
def change_white(targets, targetsegments, targetcolor):
def change_blue(targets, targetsegments, targetcolor):
def change_purple(targets, targetsegments, targetcolor):

# haven't decided how to disambiguate between dance effects, fire spins, double chances, etc
def respin(targets):

# Allows for small number of functions that accomodate effects like Infiltrate, Ghost Sensor, Soar, etc in all different ways
def bypass_all(exceptions):
def bypass_none(exceptions):

# most figures will probably have a block_none(enemy) statement, but undecided on how to make bypass override block in the right ways
def block_all(exceptions):
def block_none(exceptions):

# Allows checking of immune list in figure objects for things like status, KO, movement, etc
def immune([KEYWORDS]):

# for "When this is KO'd" effects
def receiveKO(relevantFunctions()):
# considers that all KOs allow evolution
def giveKO(evolve(user), relevantFunctions()):
# not yet sure how to differentiate between Synthesis-like effects and global auras
def changeDamage(targets, amount, *targetsegments, *targetcolor)
def changeStars(targets, amount, *targetsegments)
def changeMove(targets, amount)
#For things like Celesteela Flame Gun, could also cover Z-Moves
def changeAttack(targets, targetsegments, newattack())
